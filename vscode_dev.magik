#% text_encoding = iso8859_1
_package sw
$

# Contains the minimal set of Magik development procs to support working with Magik in VS Code.

# Note: Please reload open_file() below if the dev procs are loaded from magik_tools (e.g. if the Dev Application is loaded)


!global_auto_declare?! << _true
$


# Redefined for use with VS Code

_pragma(classify_level=debug)
## Open a file in VS Code
_global _constant open_file <<
_proc (file_path, _optional line_number, a_class, a_method)

	command << write_string("cmd /c code -r ", file_path)

	_if line_number _isnt _unset
	_then
		command << write_string("cmd /c code -r --goto ", file_path, ":", line_number)

	_elif a_method _isnt _unset
	_then
		# Find the method declaration in the file to get the line number
		class_name << a_method.owner.meta_at(:class_name)
		method_name << a_method.name
		last << method_name.subseq(method_name.size - 1, 2)

		test << _if a_method.slot_accessor?
			_then
				>> write_string("*", class_name, "*.*define_slot_access*(*:", method_name, "*")
			_elif last = "()"
			_then
				>> write_string("*_method *", class_name, "*.*", method_name.subseq(1, method_name.size - 2), "*(*")
			_elif last = "<<"
			_then
				>> write_string("*_method *", class_name, "*.*", method_name.subseq(1, method_name.size - 2), "*<<*")
			_else
				>> write_string("*_method *", class_name, "*.*", method_name, "*")
			_endif

 		_protect
			input << external_text_input_stream.new( file_path )
			line << 1
			_loop
				_if ( a_line << input.get_line() ) _is _unset
				_then
					_leave
				_endif
				_if a_line.matches?(test)
				_then
					col << a_line.size + 1
					command << write_string("cmd /c code -r --goto ", file_path, ":", line, ":", col)
					_leave
				_endif
				line +<< 1
			_endloop
		_protection
			input.close()
		_endprotect
	_endif

	system.do_command( command )

_endproc
$


_pragma(classify_level=debug)
##
## Save session info for the VS Class Browser.
## Calling this procedure will connect the Class Browser in VS Code.
##
_global _constant vs_class_browser <<
_proc @vs_class_browser()

	_if method_finder.pid _is _unset
	_then
		method_finder.start_acp()
	_endif

	output_file << system.pathname_down(system.temp_directory_name, "vscode_class_browser.txt")

	id_str << system.process_id.write_string

	output_stream << _unset
	_protect
		output_stream << external_text_output_stream.new(output_file)
		output_stream.write("processId|", id_str, newline_char)

		_for key, val _over system.get_all_env().fast_keys_and_elements()
		_loop
			str << val.write_string.replace_all_instances_of("\", "/");
			output_stream.write(key.write_string, "|", str, newline_char)
		_endloop

	_protection
		_if output_stream _isnt _unset
		_then
			output_stream.close()
		_endif
	_endprotect

_endproc
$


_pragma(classify_level=debug)
## Jump to source in VS Code
_global _constant vs_goto <<
_proc @vs_goto( method_string, _optional class_string, super? )

	_global mfind
	_global mjump

	a_class << _unset

	_if class_string _isnt _unset _andif
		class_string.an_element() _isnt %^
	_then
		key << class_string.as_symbol()
		class_string << _unset
		# Use the provided class_string if it is a global.
		_for a_package _over package.all_packages.fast_elements()
		_loop
			_if ( val << a_package[ key ] ) _isnt _unset
			_then
				a_class << val
				class_string << write_string("^", a_class.class_name, "$")
				_leave
			_endif
		_endloop
	_endif

	_if super? _is _true _andif a_class _isnt _unset
	_then
		class_string << _unset
		mt << a_class.define_method_target
		tables << rope.new()

		# Find a parent implementation
		_for parent_mt _over mt.parents( _true )
		_loop
			_if _not tables.includes?( parent_mt )
			_then
				super_class_string << write_string("^", parent_mt.meta_at(:class_name), "$")
				results << mfind( method_string, super_class_string, _unset, 2, _false, _false, _false )
				_if results.size _is 1
				_then
					mjump( 1 )
					_return
				_endif
				tables.add_last( parent_mt )
			_endif
		_endloop
	_endif

	results << mfind( method_string, class_string, _unset, 2, _false, _false, _false )

	_if results.size _is 1
	_then
		mjump( 1 )
	_else
		mfind( method_string, class_string )
	_endif

_endproc
$


_pragma(classify_level=debug)
## Proc to control a timer to monitor output and save to a temporary file to append to a console
## file in VS Code.
_global _constant vs_monitor_output <<
_proc @vs_monitor_output(enable?)

	_global timer, external_text_simple_output_stream
	_global vs_output_timer, vs_default_terminal, vs_output
	_global !output!, !error_output!, !terminal!

	_if enable? _is _true
	_then
		_if vs_output_timer _is _unset
		_then
			write("Starting output monitor...")

			_if vs_default_terminal _is _unset
			_then
				vs_default_terminal << !terminal!
			_endif

			_local simple? << external_text_simple_output_stream _isnt _unset

			_local remove_trailing_lines << _proc(a_string)
					end << 0
					_for index _over a_string.size.downto(1)
					_loop
						_if _not a_string[index].white_space?
						_then
							end << index
							_leave
						_endif
					_endloop
					_return a_string.slice(1, end)
				_endproc

			_local orig_output << !output!
			vs_output << internal_text_output_stream.new()
			!output! << !error_output! << !terminal! << vs_output

			temp_dir << _if system.os_name _is :windows
				_then
					>> system.getenv("TEMP")
				_else
					>> "/tmp"
				_endif
			_local output_file << system.pathname_down(temp_dir, "vscode_output_temp.txt")

			_try
				system.unlink(output_file, _true, _true)
			_when error
				# write("Cannot remove " + output_file)
			_endtry

			_if timer _isnt _unset
			_then
				vs_output_timer << timer.schedule_fixed_delay(
					_proc @vs_output_timer()
						_import output_file, remove_trailing_lines, simple?
						_global vs_output

						_lock vs_output
							str << vs_output.string
							_if _not str.empty? _andif str.last _is %newline
							_then
								output_stream << _unset
								done? << _false
								_protect
									_if simple?
									_then
										_try
											output_stream << external_text_simple_output_stream.new_appending(output_file)
										_when filesystem_error
											# Ignore
											_return
										_endtry
									_else
										output_stream << external_text_output_stream.new(output_file)
									_endif
									output_str << remove_trailing_lines(str)
									output_stream.write(output_str, %newline)
									done? << _true
								_protection
									_if output_stream _isnt _unset
									_then
										output_stream.close()
									_endif
									_if done?
									_then
										vs_output.reset()
									_endif
								_endprotect
							_endif
						_endlock
					_endproc,
					1.0, 0.4)
			_else
				vs_output_timer <<
					_proc @vs_output_timer()
						_import output_file, remove_trailing_lines
						_global vs_output

						_loop
							_thisthread.sleep(400)

							_lock vs_output
								str << vs_output.string
								_if _not str.empty?
								_then
									output_str << remove_trailing_lines(str)
									output_stream << _unset
									done? << _false
									_protect
										output_stream << external_text_output_stream.new(output_file)
										output_stream.write(output_str, %newline)
										done? << _true
									_protection
										_if output_stream _isnt _unset
										_then
											output_stream.close()
										_endif
										_if done?
										_then
											vs_output.reset()
										_endif
									_endprotect
								_endif
							_endlock
						_endloop
					_endproc.fork_at(_thisthread.low_background_priority)
			_endif
		_endif

	_elif vs_output_timer _isnt _unset
	_then
		_if timer _isnt _unset
		_then
			vs_output_timer.cancel()
		_else
			vs_output_timer.kill()
		_endif
		vs_output_timer << _unset
		vs_output << _unset
		!output! << !error_output! << !terminal! << vs_default_terminal
	_endif

_endproc
$


_block
	# A timer task to monitor output.
	_global vs_output_timer

	# Store the original terminal.
	_global vs_default_terminal

	# Store the output for use with the console terminal.
	_global vs_output

	_if vs_output_timer _isnt _unset
	_then
		# Restart monitor
		vs_monitor_output(_false)
		vs_monitor_output(_true)
	_else
		vs_output_timer << _unset
		vs_default_terminal << _unset
		vs_output << _unset
	_endif

_endblock
$


_pragma(classify_level=debug)
## A proc to perform the named proc and capture any output to add to a console file in VS Code.
_global vs_perform <<
_proc @vs_perform(proc_name, _gather args)

	_global get_global_value
	_global vs_output
	_global !global_auto_declare?!
	_dynamic !output!
	_dynamic !error_output!

	a_proc << get_global_value(proc_name)
	_if a_proc _is _unset _orif a_proc.class_name _isnt :procedure
	_then
		_return
	_endif

	_if vs_output _isnt _unset
	_then
		orig_output << !output!
		orig_error_output << !error_output!
		auto_declare? << !global_auto_declare?!
		_protect
			!output! << !error_output! << vs_output
			!global_auto_declare?! << _true
			a_proc.invoke(_scatter args)
		_protection
			!output! << orig_output
			!error_output! << orig_error_output
			!global_auto_declare?! << auto_declare?
		_endprotect
	_else
		a_proc.invoke(_scatter args)
	_endif

_endproc
$


_pragma(classify_level=debug)
## Load temp file created in VS Code with a custom message at the Magik terminal.
_global _constant vs_load <<
_proc @vs_load()

	_dynamic !output!

	temp_dir << _if system.os_name _is :windows
		_then
			>> system.getenv("TEMP")
		_else
			>> "/tmp"
		_endif
	source_file << system.pathname_down(temp_dir, "vscode_temp.magik")

	_if _not system.file_exists?(source_file)
	_then
		_return
	_endif

	msg << "Loading..."
	input << _unset
	_protect
		input << external_text_input_stream.new(source_file)
		_loop
			_if (a_line << input.get_line()) _is _unset
			_then
				_leave
			_endif
			_if a_line.index_of_seq("# Output:") _is 1
			_then
				msg << a_line.slice_to_end(10)
				_leave
			_endif
		_endloop
	_protection
		_if input _isnt _unset
		_then
			input.close()
		_endif
	_endprotect

	orig_output << !output!
	_protect
		!output! << internal_text_output_stream.new()
		orig_output.write(msg, %newline)

		_try _with cond
			load_file(source_file)
			lines << !output!.string.split_by(%newline);
			n_lines << lines.size
			_if (n_lines > 1)
			_then
				_for i _over range(2, n_lines)
				_loop
					_if i <> n_lines
					_then
						orig_output.write(lines[i], %newline)
					_else
						orig_output.write(lines[i])
					_endif
					# orig_output.write(lines[i], %newline)
				_endloop
			_endif
		_when error
			cond.report_on(orig_output)
		_endtry
	_protection
		!output! << orig_output
	_endprotect

_endproc
$


_pragma(classify_level=debug)
## Evaluate the temp file created in VS Code and display the result in the console magik file.
_global _constant vs_console_load <<
_proc @vs_console_load()

	_global external_text_simple_output_stream
	_global !global_auto_declare?!
	_global vs_default_terminal
	_global vs_output
	_global !terminal!
	_dynamic !output!
	_dynamic !error_output!

	temp_dir << _if system.os_name _is :windows
		_then
			>> system.getenv("TEMP")
		_else
			>> "/tmp"
		_endif

	input_file << system.pathname_down(temp_dir, "vscode_temp.magik")
	_if _not system.file_exists?(input_file)
	_then
		_return
	_endif

	output_file << _if vs_output _is _unset
		_then
			>> system.pathname_down(temp_dir, "vscode_console_temp.txt")
		_else
			>> system.pathname_down(temp_dir, "vscode_output_temp.txt")
		_endif

	_local remove_trailing_lines << _proc(a_string)
			end << 0
			_for index _over a_string.size.downto(1)
			_loop
				_if _not a_string[index].white_space?
				_then
					end << index
					_leave
				_endif
			_endloop
			_return a_string.slice(1, end)
		_endproc

	orig_output << !output!
	orig_error_output << !error_output!
	orig_terminal << !terminal!
	input_stream << _unset
	output_stream << _unset
	output_str << ""
	result << _unset
	auto_declare? << !global_auto_declare?!

	_protect
		input_stream << external_text_input_stream.new(input_file)
		output_stream << _if external_text_simple_output_stream _isnt _unset
			_then
				>> external_text_simple_output_stream.new_appending(output_file)
			_else
				>> external_text_output_stream.new(output_file)
			_endif

		_if vs_output _is _unset
		_then
			!output! << !error_output! << internal_text_output_stream.new()
		_else
			!output! << !error_output! << vs_output
			!terminal! << vs_default_terminal
		_endif

		sw4? << system.vm_version < 5
		input_lines << rope.new()
		_loop
			_if (a_line << input_stream.get_line()) _is _unset
			_then
				_leave
			_endif
			_if sw4?
			_then
				_if _not a_line.empty? _andif
					a_line[1] _isnt %# _andif
				a_line[1] _isnt %$ _andif
					(a_line.size < 9 _orif _not a_line.subseq(1, 9).eq?("_package "))
				_then
					input_lines.add_last(a_line)
				_endif
			_else
				_if a_line.size < 8 _orif a_line.subseq(1, 8) <> "# Magik>"
				_then
					input_lines.add_last(a_line)
				_endif
			_endif
		_endloop
		input_str << input_lines.join_as_strings(%newline)

		!global_auto_declare?! << _true

		result << input_str.evaluate()

		output_str << !output!.string
		output_str_empty? << output_str.empty?

		_if vs_output _is _unset _andif _not output_str_empty?
		_then
			str << remove_trailing_lines(output_str)
			output_stream.write(str, %newline)
		_endif

		_if result _isnt _unset _orif output_str_empty?
		_then
			output_stream.write(result, %newline)
		_endif

	_protection
		_if vs_output _is _unset
		_then
			error_str << !error_output!.string
			_if _not error_str.empty? _andif error_str <> output_str
			_then
				str << remove_trailing_lines(error_str)
				output_stream.write(str, %newline)
			_endif
		_endif

		_if input_stream _isnt _unset
		_then
			input_stream.close()
		_endif
		_if output_stream _isnt _unset
		_then
			output_stream.close()
		_endif

		!output! << orig_output
		!error_output! << orig_error_output
		!terminal! << orig_terminal

		!global_auto_declare?! << auto_declare?
	_endprotect

	_return result
_endproc
$


_pragma(classify_level=debug)
## Save methods names to file to load as symbols in VS Code.
_global _constant vs_save_symbols <<
	_proc @vs_save_symbols(_optional class_names)

		_global slot_access_method_name
		_global user_repository_paths

		temp_dir << _if system.os_name _is :windows
			_then
				>> system.getenv("TEMP")
			_else
				>> "/tmp"
			_endif
		output_name << system.pathname_down(temp_dir, "vscode_symbols.txt")
		temp_output_name << system.pathname_down(temp_dir, "vscode_symbols_temp.txt")

		_local core_dir << smallworld_product.product(:sw_core).directory
		_loop
			index << core_dir.index_of("\")
			_if index _is _unset _then _leave _endif
			core_dir[index] << "/"
		_endloop
		_local home_drive << _if core_dir[2] = %:
			_then
				>> core_dir.subseq(1, 2)
			_else
				>> ""
			_endif

		_if class_names _isnt _unset _andif
			system.file_exists?(output_name)
		_then
			a_set << set.new()
			_for c_name _over class_names.fast_elements()
			_loop
				a_set.add(c_name.as_symbol())
			_endloop
			class_names << a_set

			update? << _unset
			_protect
				input << external_text_input_stream.new(output_name)
				_loop
					_if (a_line << input.get_line()) _is _unset
					_then
						_leave
					_endif
					_if update? _is _unset
					_then
						update? << a_line.index_of_seq("update:") _is 1
					_elif update?
					_then
						# Previous symbol file was an update -> append these classes to new update
						class_name << a_line.split_by("|")[1].as_symbol()
						class_names.add(class_name)
					_endif
				_endloop
			_protection
				_if input _isnt _unset
				_then
					input.close()
					_thisthread.sleep(100)
				_endif
			_endprotect
			_if update? _isnt _true
			_then
				# Previous symbol file was not an update -> save all methods
				class_names << _unset
			_endif
		_endif

		_try
			system.unlink(temp_output_name, _true, _true)
		_when error
			write("Cannot remove " + temp_output_name)
			_return
		_endtry

		_try
			system.unlink(output_name, _true, _true)
		_when error
			write("Cannot remove " + output_name)
			_return
		_endtry

		_local slot_mt << slot_access_method_name.method_table
		_local serial_prefix << _if system.vm_version < 5
			_then
				>> "queued_work"
			_else
				>> sw_canvas_container.serialisation_thread_name
			_endif
		_local serial_prefix_n << serial_prefix.size + 1

		_local update_source_path << _proc @update_source_path(source_path)
				_import core_dir, home_drive

				_if source_path _is _unset
				_then
					_return ""
				_endif

				res << source_path

				_if source_path[1] = %/ _orif source_path[1] = %\
				_then
					_if source_path.index_of_seq("/sw_core/") _isnt _unset
					_then
						res << "".concatenation(core_dir, "/", source_path.split_by("/sw_core/")[2])
					_else
						a_path << "".concatenation(home_drive, source_path)
						_if system.file_exists?(a_path)
						_then
							res << a_path
						_endif
					_endif
				_endif

				_return res
			_endproc

		_local get_source_file << _proc @get_source_file(mt)
				_import update_source_path

				source_file << mt.source_file

				_if source_file _is _unset
				_then
					# Try the most common local method source file
					methods << equality_hash_table.new()
					_for m _over mt.local_methods()
					_loop
						_if _not m.slot_accessor?
						_then
							_try
								m_source_file << m.source_file
								_if m_source_file <> "Evaluated-inline"
								_then
									n << methods[m_source_file].default(0)
									methods[m_source_file] << n + 1
								_endif
							_when error
							_endtry
						_endif
					_endloop
					max << 0
					_for f, total _over methods.fast_keys_and_elements()
					_loop
						_if total > max
						_then
							source_file << f
							max << total
						_endif
					_endloop
				_endif

				_return update_source_path(source_file)
			_endproc

		_local output_class << _proc @output_class(mt, c_name, output)
				_import get_source_file
				_import slot_mt
				_import serial_prefix
				_import serial_prefix_n
				_import update_source_path

				# p_name << _if (g_var << mt.meta_at(:exemplar_global)) _isnt _unset
				# 	_then
				# 		>> g_var.package.name
				# 	_endif
				# full_c_name << write_string(p_name, ":", c_name)

				source_file << get_source_file(mt)
				methods_str << internal_text_output_stream.new()

				_for m _over mt.local_methods(_true)
				_loop
					m_name << m.name
					_if m_name _is :exemplar _orif
						m_name.method_table _is slot_mt _orif
						m_name.an_element() _is %$
					_then
						_continue
					_endif

					_if m_name.index_of_seq(serial_prefix) _is 1 _andif
						m_name.index_of(%!, serial_prefix_n) _isnt _unset
					_then
						_continue
					_endif

					classify_str << _if m.private?
						_then
							>> ",1,"
						_else
							>> ",,"
						_endif

					_if m.slot_accessor?
					_then
						methods_str.write(m_name, classify_str, "1,;")
					_else
						m_source_file << source_file
						_try
							m_file << m.source_file
							_if m_file _isnt _unset _andif
								m_file <> "Evaluated-inline" _andif
								m_file.index_of_seq("load_mutated_methods.magik") _is _unset _andif
								(c_name _is :sw_component _orif m_file.index_of_seq("sw_component.magik") _is _unset) # component properties
							_then
								m_source_file << update_source_path(m_file)
							_endif
						_when error
						_endtry
						_if m_source_file <> source_file
						_then
							methods_str.write(m_name, classify_str, ",", m_source_file, ";")
						_else
							methods_str.write(m_name, classify_str, ",;")
						_endif
					_endif
				_endloop

				parents_str << internal_text_output_stream.new()
				_for parent_mt _over mt.parents()
				_loop
					parents_str.write(parent_mt.meta_at(:class_name), ";")
				_endloop

				str << "".concatenation(c_name, "|", source_file, "|", parents_str.string, "|", methods_str.string)
				output.write(str, newline_char)
			_endproc

		done << set.new()

		output << _unset
		ok? << _false
		_protect
			output << external_text_output_stream.new(temp_output_name)

			_if class_names _isnt _unset
			_then
				output.write("UPDATE:", newline_char)

				_for c_name _over class_names.fast_elements()
				_loop
					key << c_name.as_symbol()
					a_class << _for a_package _over package.all_packages.fast_elements()
						_loop
							_if (val << a_package[key]) _isnt _unset
							_then
								_leave _with val
							_endif
						_endloop
					_if a_class _isnt _unset
					_then
						mt << a_class.define_method_target
						output_class(mt, key, output)
					_endif
				_endloop
			_else
				_for g _over package.all_globals()
				_loop
					val << g.value

					_if val _is _unset _orif
						val.class_name _is :procedure
					_then
						_if val _isnt _unset _andif
							(m_file << val.compiler_info[:source_file]) _isnt _unset
						_then
							m_file << update_source_path(m_file.as_charvec())
							output.write("GLOBAL|", g.key, "|", m_file, newline_char)
						_else
							output.write("GLOBAL|", g.key, newline_char)
						_endif
						_continue
					_endif

					mt << val.define_method_target
					c_name << mt.meta_at(:class_name)
					_if done.includes?(c_name)
					_then
						_continue
					_endif
					done.add(c_name)

					output_class(mt, c_name, output)
				_endloop

				# Add conditions
				_for cond_key, a_cond _over condition.sys!perform(:template_map).fast_keys_and_elements()
				_loop
					m_file << a_cond.module_file
					_if m_file _isnt _unset
					_then
						m_file << update_source_path(m_file.as_charvec())
						output.write("CONDITION|", cond_key, "|", m_file, newline_char)
					_else
						output.write("CONDITION|", cond_key, newline_char)
					_endif
				_endloop
			_endif

			ok? << _true
		_protection
			_if output _isnt _unset
			_then
				output.close()
				_if ok?
				_then
					_thisthread.sleep(100)
					_try
						system.rename(temp_output_name, output_name)
					_when error
						write("Cannot save symbols file")
					_endtry
				_endif
			_endif
		_endprotect

	_endproc
$


_pragma(classify_level=debug)
##
## Load the module containing the specified file.
## Adds products and loads prerequisite modules as necessary.
##
_global _constant vs_load_file <<
_proc @vs_load_file( file_path, _optional force_reload? )

	_global load_module

	_if _not system.file_exists?( file_path )
	_then
		write( "File Not Found" )
		_return
	_endif

	module_name << _unset

	(filename, dir) << system.pathname_components( file_path )
	module_dir << system.locate_file( dir, "module.def" )

	_if module_dir _isnt _unset
	_then
		res << sw_module_manager.module_roots( module_dir, _false )
		_if _not res.empty?
		_then
			module_name << res.a_key()[1]

			_if module_name _is _unset _orif
				module_name.size _is 0 _orif
				module_name[1] = %#
			_then
				module_name << _unset
				mod_def << system.pathname_down(module_dir, "module.def")
				_if system.file_exists?(mod_def)
				_then
					a_stream << _unset
					_protect
						a_stream << external_text_input_stream.new(mod_def)
						_loop
							_if (a_line << a_stream.get_line()) _is _unset
							_then
								_leave
							_endif
							a_line << a_line.trim_spaces()
							_if a_line.size > 0 _andif a_line[1] <> %#
							_then
								module_name << _if a_line.index_of(%tab) _isnt _unset
									_then
										>> a_line.split_by(%tab)[1]
									_else
										>> a_line.split_by(%space)[1]
									_endif
								_leave
							_endif
						_endloop
					_protection
						_if a_stream _isnt _unset
						_then
							a_stream.close()
						_endif
					_endprotect
				_endif
			_endif
		_endif
	_endif

	_if module_name _is _unset
	_then
		write( "Cannot find module for ", file_path )
		_return
	_endif

	_if force_reload? _isnt _true _andif
		sw_module_manager.module_is_loaded?( module_name ) _andif
		file_path.index_of_seq( ".magik" ) _isnt _unset
	_then
		load_file( file_path )
		_return
	_endif

	_if _not sw_module_manager.module_is_defined?( module_name )
	_then
		# Add the product here since we already know the module directory
		product_dir << system.locate_file( module_dir, "product.def" )
		_if product_dir _is _unset
		_then
			write( "Cannot load ", module_name, " - cannot find product." )
			_return
		_endif

		smallworld_product.add_product( product_dir )
	_endif

	load_module( module_name, force_reload? )

_endproc
$


_pragma(classify_level=debug)
## Run the test for the supplied test class and method name.
_global _constant vs_run_test <<
_proc @vs_run_test(class_name, method_name)
	_global run_tests
	_global test_case

	a_class << _unset

	key << class_name.as_symbol()
	_for a_package _over package.all_packages.fast_elements()
	_loop
		_if ( val << a_package[ key ] ) _isnt _unset
		_then
			a_class << val
			_leave
		_endif
	_endloop

	_if a_class _isnt _unset _andif
		a_class.is_kind_of?( test_case )
	_then
		name << write_string(method_name, "()")
		_for a_test _over a_class.suite().tests()
		_loop
			_if a_test.get_name() = name
			_then
				run_tests({a_test}, _false)
				_leave
			_endif
		_endloop
	_endif

_endproc
$


_pragma(classify_level=debug)
## Compiles the messages for the module containing the specified message file.
_global _constant vs_compile_messages <<
_proc @vs_compile_messages( msg_file )

	(filename, dir) << system.pathname_components( msg_file )
	dir << system.locate_file( dir, "module.def" )
	_if dir _isnt _unset
	_then
		res << sw_module_manager.module_roots( dir, _false )
		_if _not res.empty?
		_then
			a_module << sw_module_manager.module( res.a_key()[1] )
			_if a_module _isnt _unset
			_then
				a_module.compile_messages()
			_endif
		_endif
	_endif

_endproc
$


_pragma(classify_level=debug)
## This method returns the string to display during Magik debugging in VS Code.
_method object.vs_debug_string

	s << internal_text_output_stream.new()
	_if _self.is_kind_of?(dd_record_and_collection_mixin)
	_then
		_dynamic !output!
		orig_output << !output!
		_try
			!output! << s
			_self.describe_fields()
		_when error
			s.reset()
			_self.write_on(s)
		_endtry
		!output! << orig_output
	_elif _self.is_kind_of?(basic_collection_mixin) _andif
		_not {:char16_string, :symbol}.includes?(_self.class_name) _andif
		_not _self.empty?
	_then
		_if _self.responds_to?(:print_on|()|)
		_then
			_self.print_on(s)
		_else
			_self.debug_print_on(s)
		_endif
	_else
		_self.write_on(s)
	_endif
	>> s.string.as_charvec()
_endmethod
$


_pragma(classify_level=debug)
_global _constant start_ninja <<
	_proc @start_ninja(extension_path)
		_global smallworld_ninja

		_if _not sw_module_manager.module_is_loaded?(:smallworld_ninja)
		_then
			demo_dir << system.pathname_down(extension_path, "demo")
			smallworld_product.add_product(demo_dir)
			sw_module_manager.load_module(:smallworld_ninja)
		_endif

		_if smallworld_ninja _isnt _unset
		_then
			smallworld_ninja.open()
		_endif
	_endproc
$


# ---------------------------------------------------------------------------------------
# The procs below are a copy from magik_tools


_pragma(classify_level=debug)
##
## The root directory to locate local user repositories.
##
## **** Please redefine to suite your development environment ****
##
##
_global user_products_root << _if system.os_name _is :windows
	_then
		>> "C:\projects\hg\"
	_else
		>> system.pathname_down(system.getenv("HOME"), "projects", "hg")
	_endif
$


_pragma(classify_level=debug)
##
## Returns a rope of user repository paths.
## Returns the global user_repository_paths if set, otherwise
## searches the folder user_products_root (by default c:\projects\hg).
## REPO_DIR_NAME defaults to "hg".
##
_global _constant user_repo_paths <<
_proc (_optional repo_dir_name)

	_if repo_dir_name _is _unset
	_then
		repo_dir_name << "hg"
	_endif

	_global user_products_root
	_if user_products_root _is _unset
	_then
		user_products_root << _if system.os_name _is :windows
			_then
				>> "C:\projects\" + repo_dir_name + "\"
			_else
				>> system.pathname_down(system.getenv("HOME"), "projects", repo_dir_name)
			_endif
	_endif

	repo_paths << rope.new()

	_try
		dc << directory_channel.new(user_products_root)
	_when file_no_access
		write("Access denied to ", user_products_root)
	_endtry

	_if dc _is _unset
	_then
		_return repo_paths
	_endif

	_protect
		_loop
			_if (entry << dc.get_status()) _is _unset
			_then
				_leave
			_endif
			_if entry.type _is :directory
			_then
				pathname << system.canonicalise(entry.name)
				repo_paths.add_last(pathname)
			_endif
		_endloop
	_protection
		dc.close()
	_endprotect

	_return repo_paths
_endproc
$


_pragma(classify_level=debug)
##
## A collection of path strings to locate local user repositories.
##
_global user_repository_paths << user_repo_paths()
$


_pragma(classify_level=debug)
##
## Returns a local file path in a user repository if possible.
##
_global _constant check_source <<
_proc( source_file )

	_global user_repository_paths

	_if source_file _is _unset _then _return _endif

	source_file << system.canonicalise( source_file )

	_if system.file_exists?( source_file )
	_then
		_return source_file
	_endif

	working_dir << system.canonicalise( system.working_directory )
	sep << system.pathname_separator

	_for pathname _over user_repository_paths.fast_elements()
	_loop
		repo_name << system.pathname_components( pathname )
		index << source_file.index_of_seq( write_string(sep, repo_name, sep) )
		_if index _isnt  _unset
		_then
			a_file << system.pathname_down(
					  pathname,
					  source_file.slice_to_end(index + repo_name.size + 2) )
			_if system.file_exists?( a_file )
			_then
				_return a_file
			_endif
		_endif

		index << source_file.index_of_seq( working_dir )
		_if index _isnt  _unset
		_then
			a_file << system.pathname_down(
					  pathname,
					  source_file.slice_to_end(working_dir.size + 2) )
			_if system.file_exists?( a_file )
			_then
				_return a_file
			_endif
		_endif
	_endloop

_endproc
$


_pragma(classify_level=debug)
##
## Returns the source file and class for CLASS_OR_NAME which
## can be a class or a class name string.
##
_global _constant class_source <<
_proc ( class_or_name, _optional prompt_string )

	_global vs_output
	_dynamic !output!

	_if class_or_name.class_name _is :symbol
	_then
		class_or_name << class_or_name.write_string
	_endif

	_if class_or_name.is_class_of?( "" )
	_then
		_local search_string << _proc ( a_string )
						s << a_string.size
						_if s > 0
						_then
							_for i, c _over a_string.fast_keys_and_elements()
							_loop
								_if c _is %space
								_then
									a_string[i] << %*
								_endif
							_endloop

							a_stream << internal_text_output_stream.new()
							_if a_string[1] _is %^
							_then
								start << 2
							_else
								a_stream.put( %* )
								start << 1
							_endif
							_if a_string[s] _is %$
							_then
								a_stream.write( a_string.slice(start, s - 1) )
							_else
								a_stream.write( a_string.slice(start, s) )
								a_stream.put( %* )
							_endif
							_return a_stream.string
						_else
							_return _unset
						_endif
					_endproc

		class_test << search_string( class_or_name )

		_if class_test _is _unset
		_then
			write( "Cannot open file for ", %', class_or_name, %' )
			_return _unset, :cancel
		_endif

		results << equality_set.new()

		_for g _over package.all_globals()
		_loop
			val << g.value
			_if val _is _unset _orif
			    val.class_name _is :procedure
			_then
				_continue
			_endif
			mt << val.define_method_target
			class_name << mt.meta_at(:class_name)
			_if class_name.matches?( class_test )
			_then
				results.add( mt )
			_endif
		_endloop

		n_results << results.size

		_if n_results _is 0
		_then
			write( "Found no matches for ", %', class_or_name, %' )
			_return

		_elif n_results > 1
		_then
			sorted_results << sorted_collection.new( n_results,
								 _proc( a, b )
									 >> a[2] _cf b[2]
								 _endproc )

			max_s << 0
			_for res _over results.fast_elements()
			_loop
				class_name << res.meta_at(:class_name)
				max_s << max_s.max( class_name.size )
				sorted_results.add( {res, class_name} )
			_endloop

			_local add_spaces << _proc ( a_stream, n )
						     _over range(1, n)
						     _loop
							     a_stream.put( %space )
						     _endloop
					     _endproc

			write( n_results, " results found" )
			write()
			max << 25
			_for i, v _over sorted_results.fast_keys_and_elements()
			_loop
				res_stream << internal_text_output_stream.new()
				res_stream.write( %[, i, %] )
				_if i < 10 _andif n_results > 9
				_then
					add_spaces( res_stream, 3 )
				_else
					add_spaces( res_stream, 2 )
				_endif
				class_name << v[2]
				res_stream.write( class_name )
				module_name << v[1].meta_at(:exemplar).module_name
				_if module_name _isnt _unset
				_then
					add_spaces( res_stream, max_s - class_name.size + 3 )
					res_stream.write( %(, module_name, %) )
				_endif
				write( res_stream.string )
				_if i _is max
				_then
					write( "..." )
					_leave
				_endif
			_endloop
			write()

			_if vs_output _isnt _unset
			_then
				_return _unset, :cancel
			_endif

			_if prompt_string _is _unset
			_then
				prompt_string << "Display source (index)> "
			_endif
			!output!.write( prompt_string )
			reply << !terminal!.get_line().trim_spaces()
			index << reply.as_number()
			_if index _is _unset
			_then
				_return _unset, :cancel
			_endif

			mt << sorted_results[ index ][1]
		_else
			mt << results.an_element()
		_endif
	_else
		mt << class_or_name.define_method_target
	_endif

	_if mt _isnt _unset _andif
	    ( source_file << check_source( mt.source_file ) ) _isnt _unset
	_then
		_return source_file, mt.meta_at(:exemplar)
	_else
		# Try the most common local method source file
		methods << equality_hash_table.new()
		_for m _over mt.local_methods()
		_loop
			_if _not m.slot_accessor?
			_then
				m_source_file << m.source_file
				_if m_source_file <> "Evaluated-inline"
				_then
					n << methods[ m_source_file ].default(0)
					methods[ m_source_file ] << n + 1
				_endif
			_endif
		_endloop
		max << 0
		_for f, total _over methods.fast_keys_and_elements()
		_loop
			_if total > max
			_then
				source_file << f
				max << total
			_endif
		_endloop

		_if ( source_file << check_source( source_file ) ) _isnt _unset
		_then
			_return source_file, mt.meta_at(:exemplar)
		_else
			write( "Cannot find source for ", %', class_or_name, %' )
		_endif
	_endif

_endproc
$


_pragma(classify_level=debug)
##
## Opens the source file in VS Code for CLASS_OR_NAME which can
## be a class or a class name string.
##
## A prompt to choose a class is displayed if multiple classes
## are found matching the supplied string.
##
## Examples:
##  open_class( sw_item )
##  open_class( "map" )
##  open_class( "_container$" )
##  open_class( "text stream" )
##
_global _constant open_class <<
_proc ( class_or_name, _optional line_number )

	_global class_source

	(source_file, a_class) << class_source( class_or_name )

	_if source_file _isnt _unset _andif a_class.class_name _is :unset
	_then
		write( "No class found!" )
		_return
	_endif

	_if source_file _isnt _unset
	_then
		open_file( source_file, line_number, a_class )
	_endif

_endproc
$


_pragma(classify_level=debug)
##
## Opens the source file in VS Code for CLASS_OR_NAME which can
## be a class or a class name string.
## Abbreviation of open_class()
##
_global _constant oc << open_class
$


_pragma(classify_level=debug)
##
## Loads the specified module.
## Searches for the module if not defined and adds the product.
##
_global _constant load_module <<
_proc ( module_name, _optional force_reload? )

	_global user_repository_paths

	load_prerequisites? << _false

	_if _not sw_module_manager.module_is_defined?( module_name )
	_then
		module_dir << _unset

		sep << system.pathname_separator

		write( "Searching for module..." )

		_for a_path _over user_repository_paths.fast_elements()
		_loop
			_if _not system.file_exists?( a_path )
			_then
				_continue
			_endif

			a_command << write_string( "cmd /c dir ", a_path, sep, "*", module_name, " /s/b" )

			(pid, in, out, err) << system.start_command_with_io( a_command, _false, _true,
									     :output, a_path )
			_protect
				result << out.get_line()
			_protection
				out.close()
			_endprotect

			_if result <> "File Not Found"
			_then
				module_dir << result
				_leave
			_endif
		_endloop

		# TODO - should check module.def file

		_if module_dir _is _unset
		_then
			write( "Cannot load ", module_name, " - cannot locate module." )
			_return
		_endif

		product_dir << system.locate_file( module_dir, "product.def" )
		_if product_dir _is _unset
		_then
			write( "Cannot load ", module_name, " - cannot find product." )
			_return
		_endif

		smallworld_product.add_product( product_dir )

		_if _not sw_module_manager.module_is_defined?( module_name )
		_then
			write( "Cannot load ", module_name, " - module not defined." )
			_return
		_endif

		load_prerequisites? << _true
		force_reload? << _true
	_endif

	_if _not sw_module_manager.module_is_loaded?( module_name ) _orif
	    force_reload? _isnt _unset
	_then
		_if _not load_prerequisites?
		_then
			a_module << sw_module_manager.module( module_name )
			_for data _over a_module.prerequisites.fast_elements()
			_loop
				_if _not sw_module_manager.module_is_defined?( data.an_element() )
				_then
					load_prerequisites? << _true
					_leave
				_endif
			_endloop
		_endif

		_if load_prerequisites?
		_then
			a_module << sw_module_manager.module( module_name )
			_for data _over a_module.prerequisites.fast_elements()
			_loop
				load_module( data.an_element(), force_reload? )
			_endloop
		_endif

		_try _with cond
			sw_module_manager.load_module( module_name, _unset,
						       :force_reload?, force_reload? )

		_when sw_module_required_module_not_defined
			write( "Cannot load ", module_name, " - required module not defined." )
		_endtry
	_else
		write( module_name, " - already loaded." )
	_endif

_endproc
$


_pragma(classify_level=debug)
##
## Load the module containing the specified file.
## Finds the file and adds products and loads prerequisite
## modules as necessary.
##
## Useful for loading a test after starting a session e.g.
## load_file_name( "sw_container_test", "corerepo" )
##
## SEARCH_PATH is the directory or repo name (e.g. "corerepo")
## to search. Defaults to the paths defined by
## user_repository_paths.
##
_global _constant load_file_name <<
_proc ( file_name, _optional search_path, force_reload? )

	_global user_repository_paths
	_global load_module
	_global vs_output
	_dynamic !output!

	paths << _unset
	_if search_path _isnt _unset
	_then
		_if search_path.index_of( system.pathname_separator ) _is _unset
		_then
			paths << _for pathname _over user_repository_paths.fast_elements()
		                 _loop
					 name << system.pathname_components( pathname )
					 _if name = search_path
					 _then
						 _leave _with {pathname}
					 _endif
				 _endloop
		_else
			paths << {search_path}
		_endif
	_endif
	_if paths _is _unset
	_then
		paths << user_repository_paths
	_endif

	_if _not file_name.includes?( %. )
	_then
		file_name << write_string( file_name, ".magik" )
	_endif

	sep << system.pathname_separator

	matches << rope.new()

	start_time << system.elapsed_seconds()

	write( "Searching for file..." )

	_for a_path _over paths.fast_elements()
	_loop
		_if _not system.file_exists?( a_path )
		_then
			_continue
		_endif

		a_command << write_string( "cmd /c dir ", a_path, sep, "*", file_name, " /s/b" )

		(pid, in, out, err) << system.start_command_with_io( a_command, _false, _true,
								     :output, a_path )

		_protect
			_loop
				_if ( a_line << out.get_line() ) _is _unset
				_then
					_leave
				_endif
				_if a_line <> "File Not Found" _andif
				    a_line.last _isnt %# _andif
				    a_line.includes?( %. ) _andif
				    a_line.index_of_seq( "\.hg\" ) _is _unset
				_then
					matches.add_last( a_line )
				_endif
			_endloop
		_protection
			out.close()
		_endprotect
	_endloop

	_if matches.empty?
	_then
		write( "File Not Found" )
		_return

	_elif matches.size > 1
	_then
		f << float_format.new_with_properties( :float_decimal_places, 0 )
		search_time << (system.elapsed_seconds() - start_time) * 1000
		write( matches.size, " results found        (Search time: ", f.format(search_time), " ms)" )
		write()

		_for i, p _over matches.fast_keys_and_elements()
		_loop
			(f, d) << system.pathname_components( p )
			write( "[", i, "]  ", f, "    ", d )
			_if i _is 25
			_then
				write("...")
				_leave
			_endif
		_endloop
		write()

		_if vs_output _isnt _unset
		_then
			_return
		_endif

		!output!.write( "Load file (index)> " )
		reply << !terminal!.get_line().trim_spaces()
		_if ( index << reply.as_number() ) _is _unset _orif
		    index < 1 _orif
		    index > matches.size
		_then
			_return
		_endif

		file_path << matches[ index ]
	_else
		file_path << matches.an_element()
	_endif

	module_name << _unset

	(filename, dir) << system.pathname_components( file_path )
	module_dir << system.locate_file( dir, "module.def" )
	_if module_dir _isnt _unset
	_then
		res << sw_module_manager.module_roots( module_dir, _false )
		_if _not res.empty?
		_then
			module_name << res.a_key()[1]
		_endif
	_endif

	_if module_name _is _unset
	_then
		write( "Cannot find module for ", file_path )
		_return
	_endif

	_if force_reload? _isnt _true _andif
		sw_module_manager.module_is_loaded?( module_name ) _andif
	    file_path.index_of_seq( ".magik" ) _isnt _unset
	_then
		load_file( file_path )
		_return
	_endif

	_if _not sw_module_manager.module_is_defined?( module_name )
	_then
		# Add the product here since we already know the module directory
		product_dir << system.locate_file( module_dir, "product.def" )
		_if product_dir _is _unset
		_then
			write( "Cannot load ", module_name, " - cannot find product." )
			_return
		_endif

		smallworld_product.add_product( product_dir )
	_endif

	load_module( module_name, force_reload? )

_endproc
$


_pragma(classify_level=debug)
##
## Last results from mfind() used by mjump()
##
_global mfind_results << {}
$


_pragma(classify_level=debug)
##
## Defines whether mfind() displays method arguments in its results.
##
_global mfind_args? << _false
$


_pragma(classify_level=debug)
##
## Returns a rope of the source lines of the method and the
## start and end line number in the source file.
##
_global _constant method_lines <<
_proc ( a_method, _optional source_file )

	_global check_source

	_if source_file _is _unset
	_then
		_if ( source_file << check_source( a_method.source_file ) ) _is _unset _orif
			source_file = "Evaluated-inline" _orif
		    source_file.index_of_seq( "register_mutating_methods.magik" ) _isnt _unset _orif
		    source_file.index_of_seq( "load_mutated_methods.magik" ) _isnt _unset
		_then
			source_file << check_source( a_method.owner.source_file )
		_endif
	_endif

	_if source_file _is _unset
	_then
		_return
	_endif

	file_lines << rope.new()
	_protect
		input << external_text_input_stream.new( source_file )
		_loop
			_if ( input_line << input.get_line() ) _is _unset
			_then
				_leave
			_endif
			file_lines.add_last( input_line )
		_endloop
	_protection
		input.close()
	_endprotect

	class_name << a_method.owner.meta_at(:class_name)
	method_name << a_method.name
	n << _unset
	_for c _over {%(, %<, %[}.fast_elements()
	_loop
		_if ( n << method_name.index_of( c ) ) _isnt _unset
		_then
			_leave
		_endif
	_endloop
	_if n _isnt _unset
	_then
		method_name << method_name.subseq( 1, n - 1 )
	_endif

	start_str << write_string( "_method ", class_name, ".", method_name )
	start_str_size << start_str.size
	end_str << "_endmethod"
	end_str_size << end_str.size

	method_lines << rope.new()
	start << end << _unset

	found? << _false
	_for r, a_line _over file_lines.fast_keys_and_elements()
	_loop
		n << a_line.size
		_if found?
		_then
			method_lines.add_last( a_line )
			_if n >= end_str_size _andif
			    a_line.index_of_seq( end_str ) _isnt _unset
			_then
				end << r
				_leave
			_endif
		_else
			_if n > start_str_size _andif
			    a_line.index_of_seq( start_str ) _isnt _unset
			_then
				found? << _true
				start << r
				method_lines.add_last( a_line )
			_endif
		_endif
	_endloop

	_if start _isnt _unset _andif
	    start _isnt 1 _andif
	    file_lines[ start - 1 ].index_of_seq( "_pragma" ) _isnt _unset
	_then
		method_lines.add_first( file_lines[ start - 1 ] )
		start -<< 1
	_endif

	_return method_lines, start, end
_endproc
$


_pragma(classify_level=debug)
##
## Send a method in the mfind results to VS Code.
##
## Update global user_repository_paths to define repository paths.
##
## Example:
##  mjump( 1 )  ->  Show the source of the first result from mfind()
##
_global _constant mjump <<
_proc ( results_index, _optional results )

	_global check_source
	_global open_file

	_if results _is _unset
	_then
		_global mfind_results
		results << mfind_results
	_endif

	_if results_index < 1 _orif results_index > results.size
	_then
		_return
	_endif

	a_method << results[ results_index ]
	line_number << _unset
	source_file << _unset

	_if a_method.is_class_of?( {} )
	_then
		(a_method, line_number, source_file) << (_scatter a_method)
		_if source_file _isnt _unset
		_then
			source_file << check_source( source_file )
		_endif
	_endif

	_if a_method _isnt _unset _andif
	    source_file _is _unset
	_then
		_if a_method.slot_accessor? _orif
			( source_file << check_source( a_method.source_file ) ) _is _unset _orif
			source_file = "Evaluated-inline" _orif
		    source_file.index_of_seq( "register_mutating_methods.magik" ) _isnt _unset _orif
		    source_file.index_of_seq( "load_mutated_methods.magik" ) _isnt _unset
		_then
			source_file << check_source( a_method.owner.source_file )
		_endif
	_endif

	_if source_file _is _unset
	_then
		write( "Cannot open source!" )
		_return
	_endif

	_if a_method _isnt _unset _andif
	    line_number _isnt _unset
	_then
		# Check line number
		(lines, start, end) << method_lines( a_method )
		_if start _is _unset
		_then
			line_number << _unset
		_else
			_if line_number <= start
			_then
				line_number << start + line_number - 1
			_endif

			_if line_number <= start _orif
			    line_number >= end
			_then
				line_number << _unset
			_endif
		_endif
	_endif

	open_file( source_file, line_number, _unset, a_method )

_endproc
$


_pragma(classify_level=debug)
##
## Displays methods matching the method and class name string.
##
## mjump( <index> ) can be used to send the method to VS Code.
##
## MODE - can be one of
##  :local (or :loc),
##  :inherit (or :inh),
##  :inherit_not_object (or :obj).
##  Defaults to :inherit
##
## MAX - the maximum number of results. Defaults to 25.
##
## DISPLAY_RESULTS? - list the method results on the
##  terminal if set to true. Otherwise returns a rope of
##  matching methods. Defaults to true.
##
## DISPLAY_ARGS? - show the method arguments for the results.
##  Press 'a' at the 'Display source>' prompt to show the
##  arguments. Defaults to false.
##
## PROMPT? - show an input prompt to choose the method source
##  to display. Defaults to true.
##
_global _constant mfind <<
_proc ( method_string, _optional class_string, mode, max,
	display_results?, display_args?, prompt? )

	_global slot_access_method_name
	_global display_mfind_results
	_global mprompt
	_global vs_output

	time << system.elapsed_seconds()

	results << set.new()

	_if method_string _is _unset
	_then
		method_string << ""
	_else
		method_string << method_string.write_string
	_endif

	_if class_string _is _unset
	_then
		class_string << ""
	_else
		class_string << class_string.write_string
	_endif

	_if mode _is _unset
	_then
		mode << :inherit
	_endif
	_if max _is _unset
	_then
		max << 25
	_endif

	_if display_results? _is _unset
	_then
		display_results? << _true
	_endif
	_if display_args? _is _unset
	_then
		_global mfind_args?
		display_args? << mfind_args?
	_endif

	_local match_mode <<
		_proc( a_string )
			s << a_string.size
			_if s = 0
			_then
				_return :all

			_elif s = 1
			_then
				_return :seq

			_elif a_string.index_of( %space ) _isnt _unset _orif
			      a_string.index_of( %* ) _isnt _unset
			_then
				_return :match
			_else
				first? << a_string[1] _is %^
				last? << a_string[s] _is %$
				_if first? _andif last?
				_then
					_return :equal

				_elif first?
				_then
					_return :seq_first

				_elif last?
				_then
					_return :seq_last
				_else
					_return :seq
				_endif
			_endif
		_endproc

	class_mode << match_mode( class_string )
	method_mode << match_mode( method_string )

	_local test_string <<
		_proc( a_string )
			end << a_string.size
			_if end = 0
			_then
				_return

			_elif end = 1
			_then
				_return a_string
			_else
				match? << a_string.index_of( %space ) _isnt _unset _orif
					  a_string.index_of( %* ) _isnt _unset

				_if match?
				_then
					_for i, c _over a_string.fast_keys_and_elements()
					_loop
						_if c _is %space
						_then
							a_string[i] << %*
						_endif
					_endloop
				_endif

				a_stream << internal_text_output_stream.new()
				_if a_string[1] _is %^
				_then
					start << 2
				_else
					_if match? _andif a_string[1] _isnt %*
					_then
						a_stream.put( %* )
					_endif
					start << 1
				_endif
				_if a_string[end] _is %$
				_then
					a_stream.write( a_string.slice(start, end - 1) )
				_else
					a_stream.write( a_string.slice(start, end) )
					_if match? _andif a_string[end] _isnt %*
					_then
						a_stream.put( %* )
					_endif
				_endif
				_return a_stream.string
			_endif
		_endproc

	class_test << test_string( class_string )
	method_test << test_string( method_string )

	_local match_string? <<
		_proc( name, test, mode )
			_if mode _is :seq
			_then
				_return name.index_of_seq( test ) _isnt _unset

			_elif mode _is :equal
			_then
				_return name = test

			_elif mode _is :seq_first
			_then
				_return name.index_of_seq( test ) _is 1

			_elif mode _is :seq_last
			_then
				_return name.index_of_seq( test ) _is name.size - test.size + 1

			_elif mode _is :match
			_then
				_return name.matches?( test )
			_else
				# :all
				_return _true
			_endif
		_endproc

	#show( method_test, method_mode, class_test, class_mode )

	local? << class_test _is _unset _orif
		  mode _is :local _orif
		  mode _is :loc

	not_object? << mode _is :inherit_not_object _orif
		       mode _is :obj

	slot_mt << slot_access_method_name.method_table
	serial_prefix << _if system.vm_version < 5
		_then
			>> "queued_work"
		_else
			>> sw_canvas_container.serialisation_thread_name
		_endif
	serial_prefix_n << serial_prefix.size + 1
	monitor_prefix << "object_monitor!"
	monitor_prefix_n << monitor_prefix.size + 1

	n << 0
	done << set.new()
	methods_to_ignore << set.new()

	_for g _over package.all_globals()
	_loop
		val << g.value
		_if val _is _unset _orif
		    val.class_name _is :procedure
		_then
			_continue
		_endif

		mt << val.define_method_target
		class_name << mt.meta_at(:class_name)
		_if done.includes?( class_name )
		_then
			_continue
		_endif
		done.add( class_name )

		_if class_test _isnt _unset _andif
		    _not match_string?( class_name, class_test, class_mode )
		_then
			_continue
		_endif

		_for m _over mt.elements()
		_loop
			_if local? _andif
			    m.owner _isnt mt
			_then
				_continue
			_endif

			_if not_object? _andif
			    m.owner _is mt
			_then
				_continue
			_endif

			m_name << m.name
			_if m_name _is :exemplar _orif
			    m_name.method_table _is slot_mt _orif
			    m_name.an_element() _is %$
			_then
				_continue
			_endif

			_if method_test _isnt _unset _andif
			    _not match_string?( m_name, method_test, method_mode )
			_then
				_continue
			_endif

			_if m_name.index_of_seq( serial_prefix ) _is 1 _andif
			    m_name.index_of( %!, serial_prefix_n ) _isnt _unset
			_then
				_continue
			_endif

			_if m_name.index_of_seq( monitor_prefix ) _is 1 _andif
			    m_name.index_of( %!, monitor_prefix_n ) _isnt _unset
			_then
				_continue
			_endif

			_if _not methods_to_ignore.includes?( m )
			_then
				c_name << _if local?
					  _then
						  >> class_name
					  _else
						  >> m.owner.meta_at(:class_name)
					  _endif
				results.add( {m, m_name, c_name} )

				methods_to_ignore.add( m )

				n +<< 1
			_endif
		_endloop
	_endloop

	sorted_results << sorted_collection.new( _unset,
						 _proc( a, b )
							 res << a[2] _cf b[2]
							 _if res _is _maybe
							 _then
								 _return a[3] _cf b[3]
							 _else
								 _return res
							 _endif
						 _endproc )
	sorted_results.add_all( results )

	all_methods << rope.new()
	methods << rope.new()
	_for i, v _over sorted_results.fast_keys_and_elements()
	_loop
		all_methods.add_last( v[1] )
		_if i <= max
		_then
				methods.add_last( v[1] )
		_endif
	_endloop

	_global mfind_results
	mfind_results << all_methods

	_if display_results?
	_then
		f << float_format.new_with_properties( :float_decimal_places, 0 )
		search_time << (system.elapsed_seconds() - time) * 1000
		write( n, " results found        (Search time: ", f.format(search_time), " ms)" )

		display_mfind_results(1, max, display_args?)

		_if prompt? _is _false
		_then
			_return methods
		_elif n _is 0 _orif vs_output _isnt _unset
		_then
			write(" ")
		_else
			mprompt( method_string, class_string, mode, max,
				display_results?, display_args?, "Display source (index)> ", _unset, 1 )
		_endif
	_else
		_return methods
	_endif

_endproc
$


_pragma(classify_level=debug)
## Display the mfind results at the terminal.
_global _constant display_mfind_results <<
_proc (start, max, display_args?)

	_global mfind_results
	_dynamic !output!

	_if mfind_results _is _unset _orif mfind_results.empty? _then _return _endif

	end << mfind_results.size.min(start + max - 1)
	sorted_results << rope.new()

	_for res_index _over range(start, end)
	_loop
		m << mfind_results[res_index]
		c_name << m.owner.meta_at(:class_name)
		m_name << m.name
		sorted_results.add({m, m_name, c_name})
	_endloop

	m_size << 0
	c_size << 0
	_for v _over sorted_results.fast_elements()
	_loop
		m_size << m_size.max( v[2].size )
		c_size << c_size.max( v[3].size )
	_endloop

	_local add_spaces << _proc ( a_stream, n )
							_over range(1, n)
							_loop
								a_stream.put( %space )
							_endloop
						_endproc

	_local add_dots << _proc ( a_stream, n )
						a_stream.put( %space )
						_over range(1, n)
						_loop
							a_stream.put( %. )
						_endloop
						a_stream.put( %space )
					_endproc

	_local get_super_class_names
	get_super_class_names <<
		_proc ( n, t, supers )
			_import get_super_class_names
			_for parent_t _over t.parents()
			_loop
				_if ( m << parent_t.method_at( n ) ) _isnt _unset _andif
						m.owner _is parent_t
				_then
					cn << parent_t.meta_at(:class_name)
					_if _not supers.includes?( cn )
					_then
						supers.add_last( cn )
					_endif
				_else
					get_super_class_names( n, parent_t, supers )
				_endif
			_endloop
		_endproc

	write(" ")
	_if start > 1
	_then
		write("...")
	_endif

	_for i, v _over sorted_results.fast_keys_and_elements()
	_loop
		(m, m_name, c_name) << (_scatter v)
		num << i + start - 1

		res_stream << internal_text_output_stream.new()

		res_stream.write( "[", num, "]" )
		add_spaces( res_stream, end.write_string.size - num.write_string.size + 2 )

		res_stream.put_charvec( m_name )
		add_dots( res_stream, m_size - m_name.size + 3 )

		res_stream.put_charvec( c_name )
		add_spaces( res_stream, c_size - c_name.size + 3 )

		res_stream.put_charvec(
			_if m.slot_accessor?
			_then >> "slot  "
			_elif m.shared_constant?
			_then >> "const "
			_elif m.shared_variable?
			_then >> "var   "
			_elif procedure.is_class_of?(m.value)
			_then >> "method"
			#_elif iter_procedure.is_class_of?(m.value)
			#_then >> "iter  "
			_else >> ""
			_endif )

		# _if system.vm_version _is 3
		# _then
		# 	level << m.classify_level
		# 	_if level _is :restricted
		# 	_then
		# 		res_stream.put_charvec( "    " )
		# 	_else
		# 		res_stream.write( " (", level.write_string[1].uppercase, ")" )
		# 	_endif
		# _endif

		res_stream.put_charvec(
			_if m.private?
			_then >> " (P)"
			_else >> "    "
			_endif )

		res_stream.put_charvec(
			_if m.conflict?
			_then >> " (C)"
			_else >> "    "
			_endif )

		# mod_name << m.owner.meta_at(:exemplar).module_name
		# _if mod_name _isnt _unset
		# _then
		# 	res_stream.write( "  ", mod_name )
		# _endif

		super_classes << rope.new()
		get_super_class_names( m.name, m.owner, super_classes )
		_if _not super_classes.empty?
		_then
			res_stream.write( " (", super_classes.join_as_strings(", "), ")" )
		_endif

		write( res_stream.string )

		_if display_args? _is _true _andif
				( p << m.value ).class_name _is :procedure _andif
				_not ( arg_list << p.basic_arglist ).empty?
		_then
			res_stream << internal_text_output_stream.new()

			add_spaces( res_stream, end.write_string.size + 6 )
			res_stream.put_charvec( "( " )

			n_args << arg_list.size
			first_opt << p.num_mandatory_args + 1
			gather << _if p.gather_arg?
					_then
						>> n_args
					_else
						>> n_args + 1
					_endif

			_for arg_index, arg _over arg_list.fast_keys_and_elements()
			_loop
				_if arg_index _is first_opt
				_then
					res_stream.put_charvec( "_optional " )

				_elif arg_index _is gather
				_then
					res_stream.put_charvec( "_gather " )
				_endif

				res_stream.put_charvec( arg )

				_if arg_index _isnt n_args
				_then
					res_stream.put_charvec( ", " )
				_endif
			_endloop

			res_stream.put_charvec( " )" )

			write( res_stream.string )
		_endif
	_endloop

	_if mfind_results.size > start + max - 1
	_then
		write("...")
	_endif
	write(" ")

_endproc
$


_pragma(classify_level=debug)
##
## Start the mfind prompt.
##
_global _constant mprompt <<
_proc ( _optional method_string, class_string, mode, max,
	display_results?, display_args?, prompt_string, callback, start )

	_global mfind_results
	_global display_mfind_results
	_global check_source
	_global open_file
	_global vs_output
	_dynamic !output!
	_dynamic !terminal!

	_if vs_output _isnt _unset
	_then
		_return
	_endif

	_if method_string _is _unset
	_then
		method_string << ""
	_else
		method_string << method_string.write_string
	_endif

	_if class_string _is _unset
	_then
		class_string << ""
	_else
		class_string << class_string.write_string
	_endif

	_if mode _is _unset
	_then
		mode << :inherit
	_endif
	_if max _is _unset
	_then
		max << 25
	_endif
	_if start _is _unset
	_then
		start << 1
	_endif

	_if display_results? _is _unset
	_then
		display_results? << _true
	_endif
	_if display_args? _is _unset
	_then
		_global mfind_args?
		display_args? << mfind_args?
	_endif

	!output!.write( prompt_string.default( "mfind> " ) )
	reply << !terminal!.get_line().trim_spaces()
	_if reply = "$"
	_then
		reply << !terminal!.get_line().trim_spaces()
	_endif

	n << reply.size
	_if n > 1 _andif
	    reply[n] _is %s _andif
	    ( index << reply.subseq(1, n - 1).as_number() ) _isnt _unset _andif
	    index > 0 _andif
	    index <= mfind_results.size
	_then
		_local get_super_methods
		get_super_methods <<
			_proc ( n, t, supers )
				_import get_super_methods
				_for parent_t _over t.parents()
				_loop
					_if ( m << parent_t.method_at( n ) ) _isnt _unset _andif
					    m.owner _is parent_t
					_then
						_if _not supers.includes?( m )
						_then
							supers.add_last( m )
						_endif
					_else
						get_super_methods( n, parent_t, supers )
					_endif
				_endloop
			_endproc

		a_method << mfind_results[ index ]
		_if a_method.is_class_of?( {} )
		_then
			a_method << a_method.an_element()
		_endif

		supers << rope.new()
		get_super_methods( a_method.name, a_method.owner, supers )

		_if supers.empty?
		_then
			mjump( index )
		_else
			_for sm _over supers.fast_elements()
			_loop
				_if sm.slot_accessor? _orif
					( source_file << check_source( sm.source_file ) ) _is _unset _orif
					source_file = "Evaluated-inline" _orif
				    source_file.index_of_seq( "register_mutating_methods.magik" ) _isnt _unset _orif
				    source_file.index_of_seq( "load_mutated_methods.magik" ) _isnt _unset
				_then
					source_file << check_source( sm.owner.source_file )
				_endif

				method_name << sm.name
				class_name  << sm.owner.meta_at(:class_name)

				_if source_file _is _unset
				_then
					write( "Cannot open source for ", class_name, ".", method_name )
				_else
					open_file( source_file, _unset, _unset, sm )
				_endif
			_endloop
			write(" ")
		_endif

	_elif ( index << reply.as_number() ) _isnt _unset
	_then
		_if callback _isnt _unset
		_then
			callback.invoke( index )
		_elif (index > 0 _andif index < start) _orif
			(index >= start + max _andif index <= mfind_results.size)
		_then
			display_mfind_results(index, max, display_args?)

			mprompt( method_string, class_string, mode, max,
				 _true, display_args?, prompt_string, _unset, index )
		_else
			mjump( index )
		_endif

	_elif reply.lowercase = "args"
	_then
		mfind( method_string, class_string, mode, max,
		       _true, _true, _true )

	_elif reply.index_of_seq("mode=") _is 1
	_then
		new_mode << _unset
		_if reply.size > 5
		_then
			new_mode << reply.slice_to_end(6).trim_spaces()
		_endif
		_if {"loc", "local", "obj",
		     "inherit_not_object", "inh", "inherit"}.includes_by_equality?( new_mode )
		_then
			mode << new_mode
		_else
			write("Invalid Mode")
		_endif

		mprompt( method_string, class_string, mode, max,
			      _true, display_args? )

	_elif reply.index_of_seq("max=") _is 1
	_then
		new_max << _unset
		_if reply.size > 4
		_then
			new_max << reply.slice_to_end(5).trim_spaces()
		_endif
		_if new_max.as_number() _isnt _unset
		_then
			max << new_max
		_else
			write("Invalid Max")
		_endif

		mprompt( method_string, class_string, mode, max,
			      _true, display_args? )

	_elif reply.class_name _is :char16_vector _andif
	      _not reply.empty? _andif
	      reply <> "$"
	_then
		index << _unset
		_for sep _over {%,, %., %-, %;, %:, %#, %tab, %\, %/}.fast_elements()
		_loop
			_if ( index << reply.index_of(sep) ) _isnt _unset
			_then
				_leave
			_endif
		_endloop
		_if index _is _unset
		_then
			method_string << reply
		_else
			method_string << reply.slice(1, index - 1)
			class_string << reply.slice_to_end(index + 1)
		_endif

		mfind( method_string, class_string, mode, max,
		       _true, display_args?, _true )
	_endif

_endproc
$


_pragma(classify_level=debug)
##
## Displays methods matching the method and class name string.
## Abbreviation of mfind()
##
_global _constant mf << mfind
$


_pragma(classify_level=debug)
##
## Start the mfind prompt. Abbreviation of mprompt()
##
_global _constant mp << mprompt
$



_pragma(classify_level=debug)
##
## Iterator to yield elements of a collection in a random order.
##
_global _constant random_elements <<
_iter _proc(source, _optional iter_method_name)
	a_rope << _if iter_method_name _isnt _unset
		_then
			>> rope.new_from_iter(source, iter_method_name)
		_else
			>> rope.new_from(source)
		_endif

	size << a_rope.size
	max_range << 10000000
	rnd << random.new(max_range, date_time.now().as_milliseconds)

	_loop
		_if size = 0 _then _return _endif
		_if size = 1
		_then
			_loopbody(a_rope[1])
			_return
		_endif

		index << (rnd.get() * size / max_range).floor + 1
		_loopbody(a_rope.remove_nth(index))

		size -<< 1
	_endloop
_endproc
$


_pragma(classify_level=debug)
##
## Runs the supplied collection of test cases.
## Reports the total runs, assertions, failures and errors.
##
## The tests are run in separate thread if BACKGROUND? is
## true. Defaults to true.
##
## Returns the test thread if available.
##
_global _constant run_tests <<
_proc ( tests, _optional background? )

	_global load_file_name
	_global get_global_value
	_global test_case
	_global test_runner
	_global mtest_result
	_dynamic !output!

	_if tests.is_kind_of?( "" )
	_then
		load_file_name( tests )
		tests << get_global_value( tests )
	_endif

	_if tests _is _unset
	_then
		write( "Test not found!" )
		_return
	_endif

	_if _not tests.is_kind_of?( basic_collection_mixin )
	_then
		tests << {tests}
	_endif

	test_proc << _proc @run_tests( tests )

		ignore_aspects? << test_case.ignore_aspects?
		test_case.ignore_aspects? << _true

		n_runs << 0
		n_assertions << 0
		n_failures << 0
		n_errors << 0

		a_stream << internal_text_output_stream.new()
		runner << test_runner.new( a_stream )

		failing_tests << rope.new()
		tests_with_errors << rope.new()

		run_start_time << system.elapsed_seconds()

		_protect
			_for a_test _over tests.fast_elements()
			_loop
				_if a_test _is _unset _then _continue _endif

				write(" ")
				_for t _over random_elements(a_test, :|tests()|)
				_loop
					name << t.get_name()
					_if name _is _unset
					_then
						name << t.class_name
					_else
						name << write_string( t.class_name, ".", name )
					_endif
					write( "RUNNING ", name )

					start_time << system.elapsed_seconds()

					a_test_result << mtest_result.new( _false )
					t.run( a_test_result )

					end_time << system.elapsed_seconds()
					write( " Time: ", ((end_time - start_time)*1000).floor, " ms" )

					failures << a_test_result.failure_count()
					errors << a_test_result.error_count()

					a_stream.reset()
					runner.sys!slot(:test_result) << a_test_result
					runner.print()

					_if failures > 0 _orif errors > 0
					_then
						write(" ")
					_endif
					lines << a_stream.string.split_by( %newline )
					_for a_line _over lines.fast_elements()
					_loop
						write(" ", a_line)
					_endloop
					write(" ")

					n_runs +<< a_test_result.run_count()
					n_assertions +<< a_test_result.assert_count()

					_if failures > 0
					_then
						failing_tests.add_last( name )
						n_failures +<< failures
					_endif

					_if errors > 0
					_then
						tests_with_errors.add_last( name )
						n_errors +<< errors
					_endif
				_endloop
			_endloop

			_if n_runs > 1
			_then
				total_time << system.elapsed_seconds() - run_start_time

				write(" ")
				_if failing_tests.empty? _andif tests_with_errors.empty?
				_then
					write( "**** SUCCESS ****" )
				_else
					write( "**** FAILED ****" )
				_endif
				_if total_time < 1.0
				_then
					write( " Time: ", (total_time*1000).floor, " ms" )
				_else
					write( " Time: ", total_time, " s" )
				_endif

				write( " Tests run: ", n_runs, "   Tests failed: ", failing_tests.size )
				write( " Assertions: ", n_assertions, "   Failures: ", n_failures, "   Errors: ", n_errors )
				write(" ")

				_if n_runs > 8
				_then
					_if _not failing_tests.empty?
					_then
						write( "FAILURES:" )
						_for a_name _over failing_tests.fast_elements()
						_loop
							write( " ", a_name )
						_endloop
						write(" ")
					_endif

					_if _not tests_with_errors.empty?
					_then
						write( "ERRORS:" )
						_for a_name _over tests_with_errors.fast_elements()
						_loop
							write( " ", a_name )
						_endloop
						write(" ")
					_endif
				_endif
			_endif

		_protection
			test_case.ignore_aspects? << ignore_aspects?
		_endprotect

	_endproc

	_if background? _is _false
	_then
		test_proc.invoke( tests )
	_else
		_return test_proc.fork_at( _thisthread.vm_priority - 1, tests )
	_endif

_endproc
$


# End procs
# ---------------------------------------------------------------------------------------


_block
	_global vs_save_symbols
	vs_save_symbols()
_endblock
$
